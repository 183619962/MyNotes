package com.lpf.mynotes.base;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import com.lpf.mynotes.R;import android.annotation.SuppressLint;import android.app.Dialog;import android.content.Context;import android.content.DialogInterface;import android.graphics.drawable.AnimationDrawable;import android.os.Bundle;import android.os.Handler;import android.text.TextUtils;import android.util.Log;import android.view.KeyEvent;import android.view.View;import android.widget.ImageView;import android.widget.TextView;@SuppressLint("HandlerLeak")public class AsyncTaskDialog extends Dialog {	private boolean mIsAuto;	private CharSequence mText;	private OnProgressListener mListener;	private ImageView progress;	private TextView message;	/** 判断是否允许手动关闭 **/	private boolean shitDown = true;	/** 线程池 **/	ExecutorService service = Executors.newFixedThreadPool(1);	public AsyncTaskDialog(Context context) {		super(context);		// mIsAuto = true;	}	public AsyncTaskDialog(Context context, OnProgressListener listener) {		this(context);		this.mListener = listener;	}	@Override	protected void onCreate(Bundle savedInstanceState) {		// TODO Auto-generated method stub		super.onCreate(savedInstanceState);		setContentView(R.layout.dialog_progress);		progress = (ImageView) findViewById(R.id.progress_bar);		message = (TextView) findViewById(R.id.message_textview);		// 当弹框销毁的事件监听		setOnDismissListener(new OnDismissListener() {			@Override			public void onDismiss(DialogInterface dialog) {				// TODO Auto-generated method stub				if (mListener != null) {					mListener.onDismiss(AsyncTaskDialog.this);				}			}		});		// 设置弹框的按钮点击事件		setOnKeyListener(new OnKeyListener() {			@Override			public boolean onKey(DialogInterface dialog, int keyCode,					KeyEvent event) {				// TODO Auto-generated method stub				if (keyCode == KeyEvent.KEYCODE_BACK) {					if (shitDown) {						service.shutdownNow();					}				}				return false;			}		});		setCanceledOnTouchOutside(false);	}	/**	 * 设置弹框显示的文本	 * 	 * @param text	 * @return	 */	public AsyncTaskDialog setMessage(CharSequence text) {		mText = text;		if (message != null) {			message.setText(mText);		}		return this;	}	/**	 * 设置弹框的加载事件	 * 	 * @param listener	 * @return	 */	public AsyncTaskDialog setOnProgressListener(OnProgressListener listener) {		this.mListener = listener;		return this;	}	// 家在成功 失败 弹框关闭的接口回调	public interface OnProgressListener {		void onComplete(AsyncTaskDialog dialog, Throwable cause);		void onTransaction(AsyncTaskDialog dialog) throws Throwable;		void onDismiss(AsyncTaskDialog dialog);	}	public AsyncTaskDialog setAuto(boolean isAuto) {		mIsAuto = isAuto;		return this;	}	/**	 * 设置是否允许按back键手动关闭弹框	 * 	 * @param b	 */	public void shitDown(Boolean b) {		setCancelable(false);		this.shitDown = b;	}	private Handler mHandler = new Handler() {		public void handleMessage(android.os.Message msg) {			if (msg.obj == null) {				autoShow(true, null);			} else {				autoShow(false, (Throwable) msg.obj);			}		};	};	// private AsyncTask<Void, Void, Boolean> mTask;	private Thread mTask;	@Override	public void show() {		if (mListener != null) {			service.submit(new Runnable() {				@Override				public void run() {					// TODO Auto-generated method stub					Throwable cause = null;					try {						mListener.onTransaction(AsyncTaskDialog.this);					} catch (Throwable e) {						Log.i("TAG", e.getMessage());						e.printStackTrace();						cause = e;					}					mHandler.obtainMessage(1, cause).sendToTarget();				}			});		}		super.show();		// 判断显示的消息是否为空 不为空		if (!TextUtils.isEmpty(mText)) {			message.setText(mText);		} else {			message.setVisibility(View.GONE);		}		((AnimationDrawable) progress.getDrawable()).start();	}	private void autoShow(Boolean result, Throwable cause) {		if (mIsAuto) {			setCancelable(false);			message.setVisibility(View.VISIBLE);			mHandler.postDelayed(new DelayedRunnable(cause), 2000);		} else {			dismiss();			mListener.onComplete(AsyncTaskDialog.this, cause);		}	}	class DelayedRunnable implements Runnable {		Throwable cause;		DelayedRunnable(Throwable cause) {			this.cause = cause;		}		@Override		public void run() {			// TODO Auto-generated method stub			if (isShowing()) {				dismiss();			}			mListener.onComplete(AsyncTaskDialog.this, cause);		}	}}